{"version":3,"file":"transformer.js","sources":["../../src/transformer.ts"],"sourcesContent":["import { isPlainObject } from './utils'\n\nexport interface RouterTransformer {\n  stringify: (obj: unknown) => string\n  parse: (str: string) => unknown\n  encode: <T>(value: T) => T\n  decode: <T>(value: T) => T\n}\n\nexport const defaultTransformer: RouterTransformer = {\n  stringify: (value: any) =>\n    JSON.stringify(value, function replacer(key, val) {\n      const ogVal = this[key]\n      const transformer = transformers.find((t) => t.stringifyCondition(ogVal))\n\n      if (transformer) {\n        return transformer.stringify(ogVal)\n      }\n\n      return val\n    }),\n  parse: (value: string) =>\n    JSON.parse(value, function parser(key, val) {\n      const ogVal = this[key]\n      if (isPlainObject(ogVal)) {\n        const transformer = transformers.find((t) => t.parseCondition(ogVal))\n\n        if (transformer) {\n          return transformer.parse(ogVal)\n        }\n      }\n\n      return val\n    }),\n  encode: (value: any) => {\n    // When encoding, dive first\n    if (Array.isArray(value)) {\n      return value.map((v) => defaultTransformer.encode(v))\n    }\n\n    if (isPlainObject(value)) {\n      return Object.fromEntries(\n        Object.entries(value).map(([key, v]) => [\n          key,\n          defaultTransformer.encode(v),\n        ]),\n      )\n    }\n\n    const transformer = transformers.find((t) => t.stringifyCondition(value))\n    if (transformer) {\n      return transformer.stringify(value)\n    }\n\n    return value\n  },\n  decode: (value: any) => {\n    // Attempt transform first\n    if (isPlainObject(value)) {\n      const transformer = transformers.find((t) => t.parseCondition(value))\n      if (transformer) {\n        return transformer.parse(value)\n      }\n    }\n\n    if (Array.isArray(value)) {\n      return value.map((v) => defaultTransformer.decode(v))\n    }\n\n    if (isPlainObject(value)) {\n      return Object.fromEntries(\n        Object.entries(value).map(([key, v]) => [\n          key,\n          defaultTransformer.decode(v),\n        ]),\n      )\n    }\n\n    return value\n  },\n}\n\nconst createTransformer = <TKey extends string, TInput, TSerialized>(\n  key: TKey,\n  check: (value: any) => value is TInput,\n  toValue: (value: TInput) => TSerialized,\n  fromValue: (value: TSerialized) => TInput,\n) => ({\n  key,\n  stringifyCondition: check,\n  stringify: (value: any) => ({ [`$${key}`]: toValue(value) }),\n  parseCondition: (value: any) => Object.hasOwn(value, `$${key}`),\n  parse: (value: any) => fromValue(value[`$${key}`]),\n})\n\n// Keep these ordered by predicted frequency\n// Make sure to keep DefaultSerializeable in sync with these transformers\n// Also, make sure that they are unit tested in transformer.test.tsx\nconst transformers = [\n  createTransformer(\n    // Key\n    'undefined',\n    // Check\n    (v): v is undefined => v === undefined,\n    // To\n    () => 0,\n    // From\n    () => undefined,\n  ),\n  createTransformer(\n    // Key\n    'date',\n    // Check\n    (v): v is Date => v instanceof Date,\n    // To\n    (v) => v.toISOString(),\n    // From\n    (v) => new Date(v),\n  ),\n  createTransformer(\n    // Key\n    'error',\n    // Check\n    (v): v is Error => v instanceof Error,\n    // To\n    (v) => ({ ...v, message: v.message, stack: v.stack, cause: v.cause }),\n    // From\n    (v) => Object.assign(new Error(v.message), v),\n  ),\n  createTransformer(\n    // Key\n    'formData',\n    // Check\n    (v): v is FormData => v instanceof FormData,\n    // To\n    (v) => {\n      const entries: Record<\n        string,\n        Array<FormDataEntryValue> | FormDataEntryValue\n      > = {}\n      v.forEach((value, key) => {\n        const entry = entries[key]\n        if (entry !== undefined) {\n          if (Array.isArray(entry)) {\n            entry.push(value)\n          } else {\n            entries[key] = [entry, value]\n          }\n        } else {\n          entries[key] = value\n        }\n      })\n      return entries\n    },\n    // From\n    (v) => {\n      const formData = new FormData()\n      Object.entries(v).forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((val) => formData.append(key, val))\n        } else {\n          formData.append(key, value)\n        }\n      })\n      return formData\n    },\n  ),\n] as const\n\nexport type TransformerStringify<T, TSerializable> = T extends TSerializable\n  ? T\n  : T extends (...args: Array<any>) => any\n    ? 'Function is not serializable'\n    : { [K in keyof T]: TransformerStringify<T[K], TSerializable> }\n\nexport type TransformerParse<T, TSerializable> = T extends TSerializable\n  ? T\n  : T extends React.JSX.Element\n    ? ReadableStream\n    : { [K in keyof T]: TransformerParse<T[K], TSerializable> }\n\nexport type DefaultSerializable = Date | undefined | Error | FormData\n\nexport type DefaultTransformerStringify<T> = TransformerStringify<\n  T,\n  DefaultSerializable\n>\n\nexport type DefaultTransformerParse<T> = TransformerParse<\n  T,\n  DefaultSerializable\n>\n"],"names":[],"mappings":"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"}